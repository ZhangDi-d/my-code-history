#### 死锁的现象

线程 1 锁住了 A 对象，然后尝试对 B 对象进行加锁，同时线程 2 锁住了 B 对象，然后尝试对 A 对象进行加锁，这时就产生了死锁，线程1 永远得不到 B，线程2永远得不到 A。

```java
public class Account {

    private int balance;

    public Account(int balance) {
        this.balance = balance;
    }

    public Account() {
    }

    // 转账
    public void transfer(Account target, int amt) {
        // 两把锁解决线程安全问题，但是会出现死锁，当a给b转账时，b也给a转账且a获得了自己的锁，b获取了自己的锁时，会发生死锁
        synchronized (this) {
            synchronized (target) {
                if (this.balance > amt) {
                    this.balance -= amt;
                    target.balance += amt;
                }
            }
        }
    }

    @Override
    public String toString() {
        return "Account{" +
                "balance=" + balance +
                '}';
    }
}
```

阅读上面的代码，你会发现虽然两把锁解决线程安全问题，但是会出现死锁，当a给b转账时，b也给a转账且a获得了自己的锁，b获取了自己的锁时，就可能会发生死锁。要怎么解决呢？

#### 死锁出现的原因

只有以下四个条件同时发生时才会出现死锁：

1. 互斥，共享资源X和Y只能被一个线程占用；
2. 占有且等待，线程T1已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X；
3. 不可抢占，其他线程不能强行抢占线程T1占有的资源；
4. 循环等待，线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，就是循环等待。

#### 避免死锁的方法

根据死锁出现的原因，我们可以知道只要破坏四个条件中的中的任意一条，就可以避免死锁，当然互斥条件是不可破坏的，否则加锁就失去了意义，也就是说破坏其他3个条件中的任意一个就可以避免死锁。

##### 破环占有且等待

破坏占有且等待条件，只需要一次性申请所有资源即可，要么同时获取到资源，要么任何资源都获取不到。

##### 破坏不可抢占

破坏不可抢占条件，只需要长时间获取不到其他资源时，主动释放已经占有的资源。Java中 `syncronized` 关键字，无法做到主动释放占有的资源，长时间获取不到其他资源时程序会发生阻塞，但是并发包中的`Lock`是可以轻松做到。

##### 破坏循环等待

破坏这个循环等待条件，只需要对资源进行排序，然后按序申请资源